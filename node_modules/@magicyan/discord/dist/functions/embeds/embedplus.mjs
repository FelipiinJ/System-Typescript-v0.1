import { EmbedBuilder } from 'discord.js';
import { chars } from '../../constants/chars.mjs';
import { createEmbedAsset } from './assets.mjs';
import { EmbedPlusFields } from './fields.mjs';
import { createEmbedFooter } from './footer.mjs';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class EmbedPlusBuilder extends EmbedBuilder {
  constructor(data) {
    const { mergeFields = false, extends: extendsEmbed, ...embedData } = data;
    const extendsEmbedData = extendsEmbed ? "data" in extendsEmbed ? extendsEmbed.data : extendsEmbed : {};
    const { fields: extendsFields, ...extendsData } = extendsEmbedData;
    const fields = (mergeFields ? [extendsFields ?? [], data.fields ?? []].flat() : data.fields ?? extendsFields ?? []).map((field) => Object.assign(
      { name: field.name ?? chars.invisible, value: field.value ?? chars.invisible },
      field.inline !== void 0 ? { inline: field.inline } : {}
    ));
    const builderData = Object.assign({}, extendsData, embedData, { fields });
    const { color, footer, image, thumbnail, timestamp } = embedData;
    if (footer)
      Object.assign(builderData, { footer: createEmbedFooter(footer) });
    if (image)
      Object.assign(builderData, { image: createEmbedAsset(image) });
    if (thumbnail)
      Object.assign(builderData, { thumbnail: createEmbedAsset(thumbnail) });
    const embed = new EmbedBuilder(builderData);
    if (timestamp)
      embed.setTimestamp(
        typeof timestamp === "string" ? new Date(timestamp) : timestamp
      );
    if (color)
      embed.setColor(color);
    super(embed.data);
    __publicField(this, "fields");
    this.fields = new EmbedPlusFields(this);
  }
  update(data) {
    const updated = createEmbed({ mergeFields: true, extends: this, ...data });
    Object.assign(this.data, updated.data);
    return this;
  }
  has(property) {
    return Boolean(this.data[property]);
  }
  toArray() {
    return Array.from([this]);
  }
  toString(space = 2) {
    return JSON.stringify(this, null, space);
  }
  setBorderColor(color) {
    if (color === null) {
      this.setColor("#2B2D31");
    } else if (typeof color === "number") {
      this.update({ color });
    } else {
      this.setColor(color);
    }
    return this;
  }
  setAsset(asset, source) {
    if (source === null) {
      asset === "image" ? this.setImage(source) : this.setThumbnail(source);
    } else {
      this.update({ [asset]: source });
    }
    return this;
  }
  static fromInteraction(interaction, index = 0, data = {}) {
    return EmbedPlusBuilder.fromMessage(interaction.message, index, data);
  }
  static fromMessage(message, index = 0, data = {}) {
    return new EmbedPlusBuilder(Object.assign({ extends: message.embeds[index] }, data));
  }
}
function createEmbed(options) {
  const { array = false, interaction, ...data } = options;
  const embed = interaction ? EmbedPlusBuilder.fromInteraction(interaction, 0, data) : new EmbedPlusBuilder(data);
  return array ? [embed] : embed;
}

export { EmbedPlusBuilder, createEmbed };
